// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "NodeAdmin.h"
#include <concurrency/ThreadManager.h>
#include <concurrency/PlatformThreadFactory.h>
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <server/TThreadPoolServer.h>
#include <server/TThreadedServer.h>
#include <server/TNonblockingServer.h>
#include <transport/TServerSocket.h>
#include <transport/TSocket.h>
#include <transport/TBufferTransports.h>
#include <transport/TTransportUtils.h>

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
//care about the macro
#define LINESIZE 1024
#define CONFIG "./../SuperNode_Config"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

using namespace  ::csci_5105::PA1;

using namespace std;

enum State {
  INIT = 1,
  JOINING = 2,
  WORKING = 3,
  BUSY = 4,
};

struct GlobalInfo {
  int32_t curSize;
  int32_t initSize;
  int32_t maxSize;
  int32_t port;
  State state;
  vector<int32_t> ids;
  NodeList nodeList;
};

void globalInfoInit(string config, GlobalInfo & gi) {
  ifstream file;
  //take c string, i.e. char*
  file.open(config.c_str(), ios::in);
  if (!file) {
    cout << "failed to open the file!" << endl; 
    exit(1);
  }
 
  gi.curSize = 0;
  gi.state = INIT;
  
  while (!file.eof()) {
    char buffer[LINESIZE];
    file.getline(buffer, LINESIZE);
    string line(buffer);
    
    int pos = line.find('=');
    if (pos == string::npos) return;
    string variable = line.substr(0, pos);
    if (variable == "InitSize") gi.initSize = atoi(line.substr(pos + 1).c_str());
    else if (variable == "MaxSize") gi.maxSize = atoi(line.substr(pos + 1).c_str());
    else if (variable == "Port") gi.port = atoi(line.substr(pos + 1).c_str());
  }
  file.close();
}
  
void testNodeList(GlobalInfo & gi) {
  gi.ids.push_back(1);
  gi.ids.push_back(7);
  gi.ids.push_back(11);
  gi.ids.push_back(18);
  gi.ids.push_back(25);

  NodeList* temp = new NodeList();
  gi.nodeList = *temp;
  gi.nodeList.maxSize = gi.maxSize;
  /* Test nodeList.
  for (int32_t i = 4; i >= 1; i--) {
    SingleNode temp;
    temp.id = gi.ids[i];
    temp.port = gi.ids[i];
    temp.ip = boost::lexical_cast<string>(gi.ids[i]);
    gi.nodeList.id2node[temp.id] = temp; 
  }
  */
}

class NodeAdminHandler : virtual public NodeAdminIf {
 public:
  GlobalInfo globalInfo;
  
  NodeAdminHandler(GlobalInfo & gi) {
    globalInfo = gi;
    // Your initialization goes here
  }
  
  void join( ::csci_5105::PA1::NodeList& _return, const  ::csci_5105::PA1::SingleNode& newNode) {
    // Your implementation goes here
    cout << "State: " << globalInfo.state << ", Join(" << newNode.ip << ":" << newNode.port << ")" << endl;
    // Ready to add new node.
    if (globalInfo.state == INIT) {
      globalInfo.state = JOINING;
      SingleNode temp(newNode);
      temp.id = globalInfo.ids[globalInfo.curSize];
      globalInfo.nodeList.id2node[temp.id] = temp;
      _return = globalInfo.nodeList;
    } 
  }

  int32_t postJoin() {
    // Your implementation goes here
    printf("postJoin\n");
    globalInfo.curSize++;
    if (globalInfo.curSize == globalInfo.initSize) globalInfo.state = WORKING;
    else  globalInfo.state = INIT;
  }

};

int main(int argc, char **argv) {
  GlobalInfo gi;
  globalInfoInit(CONFIG, gi);
  testNodeList(gi);
  cout << "ID list: " << gi.ids.size() << endl;
  cout << "Node list: " << gi.nodeList.id2node.size() << endl;
  cout << "curSize: " << gi.curSize << endl;
  cout << "InitSize: " << gi.initSize << endl;
  cout << "MaxSize: " << gi.maxSize << endl;
  cout << "Port: " << gi.port << endl;
  
  shared_ptr<NodeAdminHandler> handler(new NodeAdminHandler(gi));
  shared_ptr<TProcessor> processor(new NodeAdminProcessor(handler));
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  // Enable multiple services with a single port.
  //shared_ptr<TMultiplexedProcessor> processor(new TMultiplexedProcessor());
  //processor->registerProcessor("NodeService", nodeProcessor);
  //processor->registerProcessor("ClientService", clientProcessor);
  
  // using thread pool with maximum 15 threads to handle incoming requests
  shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(15);
  shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();
  TNonblockingServer server(processor, protocolFactory, gi.port, threadManager);
  server.serve();
  cout << "Closing server...\n"<<endl;
  NodeList* temp = &gi.nodeList;
  delete temp;
  return 0;
}

