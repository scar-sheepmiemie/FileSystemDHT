/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef shared_TYPES_H
#define shared_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace csci_5105 { namespace PA1 {

class SingleNode;

class NodeList;

class File;

typedef struct _SingleNode__isset {
  _SingleNode__isset() : id(false), ip(false), port(false) {}
  bool id :1;
  bool ip :1;
  bool port :1;
} _SingleNode__isset;

class SingleNode {
 public:

  SingleNode(const SingleNode&);
  SingleNode& operator=(const SingleNode&);
  SingleNode() : id(0), ip(), port(0) {
  }

  virtual ~SingleNode() throw();
  int32_t id;
  std::string ip;
  int32_t port;

  _SingleNode__isset __isset;

  void __set_id(const int32_t val);

  void __set_ip(const std::string& val);

  void __set_port(const int32_t val);

  bool operator == (const SingleNode & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const SingleNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SingleNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SingleNode &a, SingleNode &b);

inline std::ostream& operator<<(std::ostream& out, const SingleNode& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NodeList__isset {
  _NodeList__isset() : maxSize(false), id2node(false) {}
  bool maxSize :1;
  bool id2node :1;
} _NodeList__isset;

class NodeList {
 public:

  NodeList(const NodeList&);
  NodeList& operator=(const NodeList&);
  NodeList() : maxSize(0) {
  }

  virtual ~NodeList() throw();
  int32_t maxSize;
  std::map<int32_t, SingleNode>  id2node;

  _NodeList__isset __isset;

  void __set_maxSize(const int32_t val);

  void __set_id2node(const std::map<int32_t, SingleNode> & val);

  bool operator == (const NodeList & rhs) const
  {
    if (!(maxSize == rhs.maxSize))
      return false;
    if (!(id2node == rhs.id2node))
      return false;
    return true;
  }
  bool operator != (const NodeList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NodeList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NodeList &a, NodeList &b);

inline std::ostream& operator<<(std::ostream& out, const NodeList& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _File__isset {
  _File__isset() : fileName(false), data(false) {}
  bool fileName :1;
  bool data :1;
} _File__isset;

class File {
 public:

  File(const File&);
  File& operator=(const File&);
  File() : fileName(), data() {
  }

  virtual ~File() throw();
  std::string fileName;
  std::string data;

  _File__isset __isset;

  void __set_fileName(const std::string& val);

  void __set_data(const std::string& val);

  bool operator == (const File & rhs) const
  {
    if (!(fileName == rhs.fileName))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const File &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const File & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(File &a, File &b);

inline std::ostream& operator<<(std::ostream& out, const File& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#endif
